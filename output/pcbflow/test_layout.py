#!/usr/bin/env python3
"""
PCBflow Layout for test_board
Generated by PCB Design Agency - Layout Agent
Date: 2025-10-04 15:52:12
"""

from pcbflow import *
import os, json
from pathlib import Path

# Built-in footprint specs (pad-geometry) to bypass KiCad libs
FOOTPRINTS = {
  'LED_0805': {
    'type': 'smt',
    'pads': [
      {'num': 1, 'shape': 'rect', 'size': [2.0, 1.2], 'at': [-1.25, 0.0]},
      {'num': 2, 'shape': 'rect', 'size': [2.0, 1.2], 'at': [ 1.25, 0.0]}
    ]
  },
  'R_0805': {
    'type': 'smt',
    'pads': [
      {'num': 1, 'shape': 'rect', 'size': [2.0, 1.2], 'at': [-1.25, 0.0]},
      {'num': 2, 'shape': 'rect', 'size': [2.0, 1.2], 'at': [ 1.25, 0.0]}
    ]
  },
  'JST_2_THT': {
    'type': 'tht',
    'pads': [
      {'num': 1, 'shape': 'circle', 'drill': 1.0, 'diameter': 2.0, 'at': [-1.0, 0.0]},
      {'num': 2, 'shape': 'circle', 'drill': 1.0, 'diameter': 2.0, 'at': [ 1.0, 0.0]}
    ]
  },
}

# Resolve KiCad footprint 'Lib:Footprint' -> absolute .kicad_mod path
def kicad_mod_path(lib_colon_fp: str) -> str:
    base = os.getenv('KICAD_FOOTPRINT_DIR', r'C:\Program Files\KiCad\9.0\share\kicad\footprints')
    if ':' not in lib_colon_fp:
        return lib_colon_fp  # already a path
    lib, fp = lib_colon_fp.split(':', 1)
    return os.path.join(base, f'{lib}.pretty', f'{fp}.kicad_mod')

# --- KiCad footprint text-layer normalizer + safe wrapper ---
import re, tempfile, io, os

def _normalize_fp_text_layers(kicad_mod_text: str) -> str:
    FRONT_DEFAULT = 'F.SilkS'
    BACK_DEFAULT  = 'B.SilkS'
    LAYER_MAP = {
        'F.SilkS':'F.SilkS', 'F.Fab':'F.Fab', 'F.CrtYd':'F.Fab',
        'B.SilkS':'B.SilkS', 'B.Fab':'B.Fab', 'B.CrtYd':'B.Fab',
    }
    def fix_layer_token(m):
        orig = m.group(1)
        if orig in LAYER_MAP:
            new = LAYER_MAP[orig]
        else:
            new = BACK_DEFAULT if orig.startswith('B.') else FRONT_DEFAULT
        return f'(layer "{new}")'
    def fix_fp_text_block(m):
        block = m.group(0)
        return re.sub(r'\(layer\s+"([^"]+)"\)', fix_layer_token, block)
    return re.sub(r'\(fp_text\b[\s\S]*?\)\s*\)', fix_fp_text_block, kicad_mod_text)

def _extract_balanced_block(s: str, start_idx: int):
    n = len(s)
    i = start_idx
    depth = 0
    in_str = False
    while i < n:
        ch = s[i]
        prev = s[i-1] if i > 0 else ''
        if ch == '"' and prev != '\\':
            in_str = not in_str
        elif not in_str:
            if ch == '(':
                depth += 1
            elif ch == ')':
                depth -= 1
                if depth == 0:
                    i += 1
                    return s[start_idx:i], i
        i += 1
    return s[start_idx:], n

def _strip_blocks(s: str, keep_predicate) -> str:
    fp_re = re.compile(r'\(fp_text\b')
    out = []
    i = 0
    n = len(s)
    while i < n:
        m = fp_re.search(s, i)
        if not m:
            out.append(s[i:])
            break
        out.append(s[i:m.start()])
        block, end_idx = _extract_balanced_block(s, m.start())
        if keep_predicate(block):
            out.append(block)
        i = end_idx
    return ''.join(out)

def _strip_fp_text_blocks_non_cu(kicad_mod_text: str) -> str:
    return _strip_blocks(kicad_mod_text, lambda block: '(layer "F.Cu")' in block or '(layer "B.Cu")' in block)

def _strip_all_fp_text(kicad_mod_text: str) -> str:
    return _strip_blocks(kicad_mod_text, lambda block: False)

# --- Pad-only sanitizer to build a minimal, pcbflow-friendly module ---
def _collect_pad_blocks(kicad_text: str) -> list[str]:
    pads = []
    i, n = 0, len(kicad_text)
    pad_re = re.compile(r'\(pad\b')
    while i < n:
        m = pad_re.search(kicad_text, i)
        if not m:
            break
        block, j = _extract_balanced_block(kicad_text, m.start())
        pads.append(block)
        i = j
    return pads

def _normalize_pad_layers(pad_block: str) -> str:
    is_smd = ' smd ' in pad_block or '(smd' in pad_block
    if is_smd:
        if 'B.Cu' in pad_block:
            return 'B.Cu B.Mask B.Paste'
        return 'F.Cu F.Mask F.Paste'
    return '*.Cu *.Mask'

def _sanitize_pad(block: str) -> str | None:
    m = re.search(r'^\(pad\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)', block)
    if not m:
        return None
    padnum, padtype, shape = m.group(1), m.group(2), m.group(3)
    shape_map = {'roundrect':'rect', 'trapezoid':'rect', 'custom':'rect'}
    shape = shape_map.get(shape, shape)
    at = '0 0'
    r = re.search(r'\(at\s+([-\d\.]+)\s+([-\d\.]+)(?:\s+([-\d\.]+))?', block)
    if r:
        at = f"{r.group(1)} {r.group(2)}" + (f" {r.group(3)}" if r.group(3) else "")
    size = '1 1'
    r = re.search(r'\(size\s+([-\d\.]+)\s+([-\d\.]+)\)', block)
    if r:
        size = f"{r.group(1)} {r.group(2)}"
    drill = None
    if padtype == 'thru_hole':
        r = re.search(r'\(drill\s+([-\d\.]+)', block)
        if r:
            drill = r.group(1)
    layers = _normalize_pad_layers(block)
    out = f'(pad {padnum} {padtype} {shape} (at {at}) (size {size})'
    if drill:
        out += f" (drill {drill})"
    out += f" (layers {layers}))"
    return out

def _build_minimal_module(orig_name: str, kicad_text: str) -> str:
    pad_lines = [_sanitize_pad(b) for b in _collect_pad_blocks(kicad_text)]
    pad_lines = [p for p in pad_lines if p]
    attr = 'smd' if pad_lines and all((' smd ' in p or 'smd' in p) for p in pad_lines) else 'thru_hole'
    lines = []
    lines.append(f'(module SANITIZED_{orig_name} (layer F.Cu))')
    lines.append('  (at 0 0)')
    lines.append(f'  (attr {attr})')
    for _p in pad_lines:
        lines.append('  ' + _p)
    return '\n'.join(lines)
def _write_temp_kicad_mod(content: str) -> str:
    d = tempfile.mkdtemp(prefix='pcbflow_fp_')
    fd, out = tempfile.mkstemp(prefix='norm_', suffix='.kicad_mod', dir=d)
    try:
        with os.fdopen(fd, 'w', encoding='utf-8', newline='\n') as f:
            f.write(content)
    except Exception:
        try: os.close(fd)
        except: pass
        raise
    return out

def normalize_kicad_mod_for_pcbflow(src_path: str) -> str:
    txt  = open(src_path, 'r', encoding='utf-8', errors='ignore').read()
    norm = _normalize_fp_text_layers(txt)
    return _write_temp_kicad_mod(norm)

def strip_kicad_mod_non_cu_text(src_path: str) -> str:
    txt  = open(src_path, 'r', encoding='utf-8', errors='ignore').read()
    stripped = _strip_fp_text_blocks_non_cu(txt)
    return _write_temp_kicad_mod(stripped)

def strip_kicad_mod_all_text(src_path: str) -> str:
    txt  = open(src_path, 'r', encoding='utf-8', errors='ignore').read()
    stripped = _strip_all_fp_text(txt)
    return _write_temp_kicad_mod(stripped)

def make_pcbflow_friendly(src_path: str) -> str:
    # Try simple text strip first
    try:
        return strip_kicad_mod_non_cu_text(src_path)
    except Exception:
        pass
    # Fallback: build minimal module from pad geometry only
    raw = open(src_path, 'r', encoding='utf-8', errors='ignore').read()
    base = os.path.splitext(os.path.basename(src_path))[0]
    mini = _build_minimal_module(base, raw)
    return _write_temp_kicad_mod(mini)

def load_footprint_spec(key: str):
    try:
        repo_root = Path(__file__).resolve().parents[2]
        fp = repo_root / 'footprints' / f'{key}.json'
        if fp.exists():
            return json.loads(fp.read_text(encoding='utf-8'))
    except Exception:
        pass
    return FOOTPRINTS.get(key)

def module_from_footprint_key(key: str) -> str:
    spec = load_footprint_spec(key)
    if not spec:
        raise RuntimeError(f'Unknown footprint key: {key}')
    lines = []
    lines.append(f'(module GEN_{key} (layer F.Cu))')
    lines.append('  (at 0 0)')
    lines.append('  (attr smd)' if spec.get('type') == 'smt' else '  (attr thru_hole)')
    for p in spec.get('pads', []):
        num = p.get('num')
        shape = p.get('shape', 'rect')
        atx, aty = p.get('at', [0.0, 0.0])
        if spec.get('type') == 'smt':
            sx, sy = p.get('size', [1.0, 1.0])
            lines.append(f'  (pad {num} smd {shape} (at {atx} {aty}) (size {sx} {sy}) (layers F.Cu F.Mask F.Paste))')
        else:
            dia = p.get('diameter', 2.0)
            drill = p.get('drill', 1.0)
            lines.append(f'  (pad {num} thru_hole {shape} (at {atx} {aty}) (size {dia} {dia}) (drill {drill}) (layers *.Cu *.Mask))')
    text = '\n'.join(lines) + '\n'
    return _write_temp_kicad_mod(text)

def safe_build_fp(dc, fp_key: str, side='top'):
    mod = module_from_footprint_key(fp_key)
    return KiCadPart(dc, libraryfile=mod, side=side)

def _assert_pads(part, ref):
    n = len(getattr(part, 'pads', []))
    if n == 0:
        raise RuntimeError(f'{ref} parsed with 0 pads â€” footprint not supported')
    print(f'{ref}: {n} pad(s)')
    return part

def safe_kicad_part(dc, lib_or_path: str, side='top'):
    path = kicad_mod_path(lib_or_path)
    friendly = make_pcbflow_friendly(path)
    return KiCadPart(dc, libraryfile=friendly, side=side)

# Board dimensions: 50mm x 20mm
brd = Board((50, 20))

# Component placement
# Strategy: Connectors on edge, LEDs/indicators visible, passives near loads
# Placement uses absolute mm coordinates

# Place J1 connector
J1 = safe_build_fp(brd.DC((25.0, 4.0)), 'JST_2_THT', side='top')

# Place D1 LED
D1 = safe_build_fp(brd.DC((25.0, 15.0)), 'LED_0805', side='top')

# Place R1 resistor near D1
R1 = safe_build_fp(brd.DC((25.0, 10.0)), 'R_0805', side='top')

# Advanced trace routing with PCBflow algorithms
# PCBflow handles Manhattan routing, obstacle avoidance, and optimization
# Net: VCC (power)
# Direct connection: J1_1 -> R1_1
brd.route_wire([J1.pads[0], R1.pads[0]], 0.25)

# Net: LED_A (signal)
# Direct connection: R1_2 -> D1_1
brd.route_wire([R1.pads[1], D1.pads[0]], 0.152)

# Net: GND (power)
# Direct connection: D1_2 -> J1_2
brd.route_wire([D1.pads[1], J1.pads[1]], 0.25)

# Add vias for layer transitions (PCBflow handles automatically)
# PCBflow will add vias where traces need to change layers
# Optimize all routes for manufacturability (best-effort)
try:
    brd.optimize_routes()
except Exception:
    pass

# Add board outline and fabrication notes (best-effort)
try:
    brd.add_outline()
except Exception:
    pass

# Save PCB file
brd.save('output.kicad_pcb')
print('âœ“ Board file saved: output.kicad_pcb')

# Generate Gerber files for manufacturing
gerber_dir = 'gerbers'
brd.save_gerbers(gerber_dir)
print(f'âœ“ Gerber files saved to {gerber_dir}/')

# Generate preview images (PNG/SVG) for quick inspection
try:
    brd.save_png('preview.png', dpi=300)
    brd.save_svg('preview.svg')
    print('âœ“ Preview images saved: preview.png, preview.svg')
except Exception as e:
    print(f'Preview generation warning: {str(e)}')